\documentclass[12pt, a4paper, openany, oneside]{book}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath} 
\usepackage{xcolor}
\usepackage[margin=1in]{geometry}
%usepackage[latin1]{inputenc}
\begin{document}
%\pagestyle{plain}
\author{DaveRhapsody \and Jacopo De Angelis \and DlcGold}
\title{Linguaggi di Programmazione}
\color{blue}
\date{30 Settembre 2019}
\color{black}
\maketitle
\tableofcontents
\chapter{Introduzione al corso}
\section{Programma del corso}
Il corso è volto ad insegnare dei paradigmi di programmazione dei seguenti tipi:
\subsection{Logica Matematica e Linguaggi logici (Prolog)}
Termini, fatti(predicati), regole, unificazione, procedura di risoluzione
\subsection{Linguaggi funzionali e Lisp (et al.)}
Atomi, liste, funzioni e ricorsione
\subsection{Linguaggi imperativi} % (fold)
\label{sub:linguaggi_imperativi}
Memoria, stato, assegnamenti, puntatori
\newline 
{\color{black} \rule{\linewidth}{0.3mm} }
\newline
Il concetto è che con questo corso si vanno a studiare paradigmi più evoluti,
usati tutt'ora e comunque aventi un ampio approccio logico, oltretutto LISP è 
usato nelle pagine web (Si userà moltissimo la ricorsione, A I U T O)
\section{Modalità d'esame}
\label{sec:modalità_d_esame}
\subsection{subsection name}
\label{sub:subsection_name}
\begin{itemize}
	\item il voto finale sarà una media pesata dei voti conseguiti nell'esame relativo alla parte teorica e nell'esame del progetto 
	\begin{itemize}
		\item Occhio, il peso è a discrezione dei prof
	\end{itemize}
\end{itemize}
\subsection{Prove parziali}
\label{sub:prove_parziali}
Le prove d'esame sono costituite da uno scritto di 6-10 domande, e da un progetto da consegnare entro una data prefissata
\section{Appelli regolari}
\label{sec:appelli_regolari}
Gli appelli regolari sono composti da un progetto ed un esame scritto, che può
essere seguito da un esame orale a discrezione del docente basato sui temi trattati durante il corso
\newline
\textbf{NON C'E' POSSIBILITA' DI RECUPERI}, infatti scritto, orale e progetto vanno sostenuti \color{red} \textbf{NELLO STESSO APPELLO} \color{black}
\newline
Progetto e scritto sono corretti separatamente
\paragraph{NON CI SARANNO ECCEZIONI}
\label{par:non_ci_saranno_eccezioni}
Lo avete già letto nel passaggio precedente, ma lo ripeto lo stesso perchè 
deve essere chiaro che N O N  S I  F A N N O  E C C E Z I O N I.
%------------------------------------------------------------------------------
\chapter{Il paradigma}
\section{Cos'è?}
E' il metodo di soluzione ad un determinato problema, a seconda dei paradigmi si
hanno diversi tipi di linguaggi di programmazione
\subsection{Storicamente}
Il primo paradigma è l'imperativo, cioè il paradigma basato sui tre costrutti
di selezione, iterazione e sequenza. \newline
Inoltre si mantiene il concetto di assegnamento di un valore ad una determinata variabile
\subsection{L'effetto collaterale}
Viene definito effetto collaterale quando, a seguito dell'esecuzione di un qualsiasi
codice, il contenuto di un'area di memoria viene cambiato; per intenderci, anche
solo l'istruzione "x += 1" genera un effetto collaterale, poichè nell'area di 
memoria di x viene cambiato il valore. \newline
Perchè è importante tutto ciò, direte. Semplice: il paradigma puro funzionale si 
basa proprio sul fatto che un programma non generi mai, mai, \emph{M A I}, effetti 
collaterali.
Successivamente vedremo che in Prolog ci saranno parecchi problemi se provassimo
ad assegnare direttamente un valore ad una variabile
\section{Logica del primo ordine}
Prolog è costituito da una serie di clausole derivanti dalla logica del primo
ordine
\section{Linguaggi funzionali}
Questi si basano proprio sui concetti matematici di funzione, ad esempio si 
ragiona sui domini, sui codomini, sull'insiemistica, solite cose
%------------------------------------------------------------------------------
\section{Paradigma imperativo}
Le caratteristiche essenziali dei linguaggi imperativi sono legate all'architettura 
di Von Neumann, costituita dai famosi due componenti 
\textbf{Memoria (componente passiva) e Processore (componente attiva)}
\newline
In pratica la principale attività che ha la cpu è quella di eseguire calcoli
ed assegnare valori alle variabili, che sono delle celle di memoria.
\paragraph{Va considerato}
Il concetto di variabile è un'astrazione di una cella di memoria, per dire 
se giochi su assembly vai a toccare i veri e propri registri, mentre su C o 
Assembly si ragiona per nome di variabile, non vai di indirizzamento fisico
%------------------------------------------------------------------------------
\subsection{Il concetto di variabile}
In Prolog e LISP cambia completamente il concetto di variabile, ma per come 
saranno presentati vedremo che non c'entra niente. \newline
In matematica abbiamo il concetto di variabile? Sì, quella che sta dentro una
funzione, in informatica è diciamo diverso, non è un'astrazione, ma lo vedremo
in seguito
\section{Modello di Von Neumann}
Per manipolare la memoria utilizzo la variabile, simbolo che indica la cella 
di memoria, nei linguaggi funzionali sarà possibile usare il concetto di 
variabile matematica. 
\newline \newline
Alla fine il modello di Neumann è composto da I/O, Memoria e CPU con i suoi 
cicli di clock
\section{Stile prescrittivo}
Un programma scritto in un linguaggio imperativo prescrive le operazioni che
la CPU deve eseguire per modificare lo stato di un sistema \newline \newline
Le istruzioni sono eseguite nell'ordine in cui queste appaiono, ad eccezione
delle strutture di controllo
\paragraph{Realizzati} sia attraverso interpretazione che compilazione, nati
più per manipolazione numerica che simbolica.
\newline
\section{Concetto di programma}
Un programma è intendibile come un insieme di algoritmi e di strutture dati
ma la struttura di un programma consiste in
\begin{itemize}
	\item Una parte dichiarativa in cui son presenti le dichiarazioni di tutte
	le variabili del programma e del loro tipo
	\item Una parte che descrive l'algoritmo risolutivo utilizzato, mediante istruzioni del linguaggio	
\end{itemize}
\section{Perchè utilizzare paradigmi diversi?}
Per esempio l'intelligenza artificiale si sviluppa su linguaggi di 
programmazione specifici, bisogna usare linguaggi che operino in un 
determinato modo, considerati tipo di Altissimo super mega galatticissifantastico livello infatti, utilizzabili pure da non programatori
\newline \newline
Infatti son generati per manipolazione simbolica non numerica 
\section{Paradigma logico}
Concetto primitivo: Deduzione logica, avente una base di logica formale e un 
obbiettivo, che è intendibile come formalizzazione del ragionamento
\newline \newline
\textbf{Programmare infatti significa} descrivere il problema con frasi 
(Formule logiche) del linguaggio, \newline
Interrogare il sistema, che effettua deduzioni in base alla "conoscenza 
rappresentata" 
\paragraph{Ai lettori} Mi rendo conto che non si capisca un cazzo, voi 
immaginatevi come mi stia sentendo al momento io mentre prendo appunti.. 
Perdonatemi
\newline \newline
Prolog è un insieme di formule ben formate, ragiona con il linguaggio logico, 
con una descrizione della realtà di interesse, di fatto è una dimostrazione in 
un linguaggio logico che costituisce un programma. Più semplicemente ho una  
frase da dare al mio interprete, Prolog icchè fa? Semplicemente la realizza  
sotto forma di dimostrazione. 
\newline 
\section{Esempio di un programma Prolog}
Ci sono fondamentalmente:
\begin{itemize}
	\item Asserzioni incondizionate (\color{red} fatti \color{black})
	A.
	\item Asserzioni condizionate (\color{red} regole \color{black})
	A :- B, C, D, ... , Z.
	\begin{itemize}
		\item A è la conclusione o conseguente (deve avere una sola clausola)
		\item B, C, D, \dots,Z sono le premesse o antecedenti 
	\end{itemize} 
	\item Un'\color{red}interrogazione \color{black} ha la forma: :- K, L, M, 
	\dots, P. \newline
\end{itemize}
Ovviamente A, B, C, *TUTTE LE ALTRE*, sono semplicemente predicati
\newline
MI RACCOMANDO MASSIMA ATTENZIONE ALLA SINTASSI, ogni clausola Prolog termina
con un punto. \newline \newline
La ',' si legge come AND
\subsection{Esempio:}
Due individui sono colleghi se lavorano per la stessa ditta/azienda
\color{red} Regole \color{blue} Fatti \color{black} Interrogazione
\newline \newline
\color{red}
collega(X, Y) :-  \newline	
lavora(X, Z), \newline	
lavora(Y, Z), \newline	
diverso(X, Y).
\newline \newline
\color{blue}
lavora(ciro, ibm)  \newline
lavora(ugo, ibm)  \newline
lavora(olivia, samsung)  \newline
lavora(ernesto, olivetti)  \newline
lavora(enrica, samsung)
\newline \newline
\color{black}
:- collega(X, Y). 
\newline
{\color{black} \rule{\linewidth}{0.3mm} }
\newline
Programmare Prolog non è come scrivere in un linguaggio di programmazione, non
si scrive un algoritmo, in questo caso abbiamo le famose clausole, (regole e 
fatti), 
\paragraph{ATTENZIONE} l'interrogazione non è una clausola, occhio a non confondersi
\subsection{Esempio dell'ordine di una lista}
\begin{itemize}
	\item Ordine prescrittivo: Controlla se la lista è vuota, e dà come risultato la lista vuota stessa, altrimenti calcola una permutazione della lista e controlla se è ordinata, dando come risultato $L_{1}$ altrimenti fa una permutazione su L etc.
	\newline
	Il programmatore deve specificare le istruzioni che generano la sequenza di permutazioni della lista L
	$
	\begin{cases}
	$il risultato dell'ordinamento di una lista vuota è la lista vuota $\\
	$Il risultato dell'ordinamento di una lista L e $L_{1} 
	\end{cases}
	$
	\item Stile Dichiarativo: L'ambiente si fa carico di generare possibili permutazioni della lista L, secondo deduzione matematica
\end{itemize}
\section{Paradigma funzionale}
\begin{itemize}
	\item 
	Si basa sul concetto di funzione matematica, ossia una associazione tra due 
	insiemi che relaziona ad ogni elemento di un insieme (dominio) un solo 
	elemento di un altro insieme (codominio)
	\item La definizione di una funzione specifica dominio, codominio, e regola di associazione 
	\newline
	\item ESEMPIO: \newline
	Incr: N $\to$ N \newline
	Incr(x) - x + 1
	\item Dopo aver dato definizione, una funzione è aopplicabile ad un elemento del 
	dominio (argomento) per restituire l'elemento del codominio ad esso associato
	(valutazione)
	\item incr(3) $\to$ 4 
	L'unica operazione utilizzata nel funzionale è l'applicazione di funzioni  
	\item Il ruolo dell'esecutore di un linguaggio funzionale si esaurisce nel calutare l'applicazione di una funzione (il programma) e produrre un valore 
	\item Nel paradigma funzionale puro il valore di una funzione è determinato dagli argomenti che riceve al momento della sua applicazione e non dallo stato del sistema rappresentato dall'insieme complessivo dei valori associati a variabili(e/o locazioni di memoria) in quel momento 
	\item Oggettivamente si ha l'assenza di effetti collaterali \newline \newline
\end{itemize}
\paragraph{Attenzione} % (fold)
\label{par:attenzione}
Il concetto di variabile che utilizziamo è quello di "costante" matematica, in 
cui i valori NON sono mutabili, non ho nessun asegnamento
\newline \newline
L'essenza della programmazione funzionale consiste nel combinare funzioni mediante composizione e uso della ricorsione
% paragraph attenzione (end)
\subsection{Composizione di funzioni + ricorsione} 
La struttura di un programma consiste nella definizione di un insieme di funzioni ricorsive mutualmente
\newline \newline
L'esecuzione del programma consiste nella VALUTAZIONE dell'APPLICAZIONE di una
funzione principale a una serie di argomenti
\section{LISP}
LISt processing, \newline \newline
Il progretto originale era di creare un linguaggio funzionale puro, infatti
nel corso degli anni sono stati sviluppati moplti ambienti di sviluppo lisp
di cui terremo in considerazione Common Lisp e Scheme, oltre che emacs etc.
\subsection{Esempio di programma LISP}
Controlla un elemento se appartiene ad una lista \newline \newline
(defun member (item list)) \newline
(cond ((null list)nil) \newline
((equal item(first list))T) \newline
(T(member item(rest list)))) \newline
(member 42(list 12 34 42)) \newline \newline
DEVO AGGIUNGERE I COLORI AIUTO CE LA POSSO FARE \newline \newline
%%AGGIUNGI I COLORI
Dopo una parentesi tonda ci va per forza una funzione, è fondamentale, defun 
definisce una funzione infatti, dopo c'è il nome di tale funzione.
\newline
Gli elementi si separano con lo spazio NON con la virgola, mi raccomando.
\newline
La terza riga è la più ostica e dice: è uguale T al primo elemento della lista?
E' molto incastrato ma si riesce a capire, associamo per esempio ad item = 2
(E' un esempio) e list = [1,2] \newline
Noi ci arriviamo con la logica che c'è, ma in realtà cosa faremo? Ragioniamo 
per gradi
\begin{enumerate}
	\item null list? \color{magenta} false \color{black}
	\item è 2 = al primo elemento della lista? \color{magenta} False \color{black}
	\item è 2 = al secondo elemento della lista? \color{blue}True \color{black}
\end{enumerate}
Se LISP trova T è come se scrivessimo  \color{blue}\textbf{true}\color{black}
\section{Ambienti RunTime di linguaggi logici funzionali e non}
\begin{itemize}
	\item Richiami di nozioni di architettura e programmazione
	\item Per eseguire un programma di qualsiasi linguaggio il sistema operativo deve mettere a disposizione l'ambiente runtime che dia almeno due funzioni
	\begin{itemize}
		\item Mantenimento dello stato della computazione(pc, limiti di memoria)
		\item Gestione memoria disponibile (fisica e virtuale)
	\end{itemize}
	\item L'ambiente runtime può essere una vera e propria macchina virtuale tipo la JVM di java
	\item In particolare la gestione di memoria avviene usando due aree concettualmente ben distinte con funzioni diverse
	\begin{itemize}
		\item Lo stack, ambiente dell'ambiente runtime che serve per la gestione delle chiamate, a procedure metodi etc
		\item L'heap dell'ambiente runtime serve per gestire strutture dinamiche
		\begin{itemize}
			\item Alberi
			\item Liste etc
		\end{itemize}
	\end{itemize}
\end{itemize}
\subsection{Activation frame}
\begin{itemize}
	\item La valutazione di procedure avviene mediante la costruzione sullo stack di sistema di activation frames
	\item i parametri formali di una procedura vengono associati ai valori (si passa tutto per valore, non esistono effetti collaterali)
	\item E' un altro modo di chiamare i record di attivazione, via
	\item Il corpo della procedura viene valutato (ricorsivamente) tenendo questi legami in maniera statica
	\newline
	cioè il concetto è che bisogna capire cosa accade con variabili che risultino libere in una sottoespressione
\end{itemize}


\end{document}